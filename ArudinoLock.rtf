{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww13920\viewh7980\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 The main idea for this project was to implement the functionality of a passcode lock. I started by hooking up the electrical components on the breadboard and gathering an understanding of the electromechanical nature of a servomotor system. Beneath my source code is a schematic for the circuit for in depth reference. \
Once I was able to properly control the servo motor, I moved on to trying to activate the servo only when the user inputs a correct code.  This was relatively simple, but I had multiple options to consider.  I chose to use a polling based code that sits in a while loop until it receives a \'93valid press\'94 signal from a helper function.  The helper function sets the corresponding button flag which is checked upon returning to the main loop. If the reset button is pressed, all stored input and counters are reset. After 5 valid presses have been stored, the input is checked against the key. If correct the servo opens, but if the input is invalid, the LED flashes thrice and the same functionality as a reset press occurs.\
(WHY POLLING?) An alternative method that may provide slightly more accurate timing functionality is using the Arduino\'92s interrupts. Since Arduino UNO (the model I used) only has two functioning interrupt ports, a little hack must be implemented.  All of the buttons can be connected to a single interrupt port AS WELL AS their unique port.  This would eliminate the need for my code to sit in a while loop as the interrupts from a button press would override the current running code.  Since I would still need to poll the unique ports to find which button triggered the interrupt, I figured I would not use this method as it didn\'92t truly help my functionality.\
Now on to adding the timing upgrade to the passcode lock\'85  My original method was hard-coding the timing constraints that must be satisfied with a max and min difference of 20 milliseconds (I know, I know, hard-coding is ignorant, but hey, you live and you learn) .  Now inside the valid press function, after I set the button flag, I record the time in milliseconds once the \'93valid press\'94 is recognized. I store the difference between the last button press and the current button press into a \'93times\'94 array.  These differences are later checked against the hard-coded timing constraints.  Through some user testing, I recognized even the best of us aren\'92t perfect metronomes, and so I allow for a 1 mistake buffer where the lock will still open. \
It was still bugging me, though, that even with a relatively simple timing pattern, this was awfully difficult to pass.  Especially when coming back to the lock the next day where the rhythm in your head is a little hazy.  I decided to fix this by changing the hardcoded times to hardcoded percentages.  Now I normalize the time differences by the total time of the combination of all the button presses.  This way, as long as you know the rhythm it isn\'92t affected if one day you\'92re moving a little slow or if you\'92re a little hyped up on some coffee or Red Bull. It turns out that this modification made the lock much more user friendly. Check out the code below for in depth explanation in the comments...}